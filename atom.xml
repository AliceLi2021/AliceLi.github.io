<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aliceli2021.github.io</id>
    <title>AliceLi&apos;s blog</title>
    <updated>2021-01-27T10:55:36.213Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aliceli2021.github.io"/>
    <link rel="self" href="https://aliceli2021.github.io/atom.xml"/>
    <logo>https://aliceli2021.github.io/images/avatar.png</logo>
    <icon>https://aliceli2021.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, AliceLi&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[KMP]]></title>
        <id>https://aliceli2021.github.io/post/kmp/</id>
        <link href="https://aliceli2021.github.io/post/kmp/">
        </link>
        <updated>2021-01-27T06:21:55.000Z</updated>
        <content type="html"><![CDATA[<p>第一次写blog qwq</p>
<h2 id="kmp模版">KMP模版</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;

using namespace std;

const int NR=1e6+5;

char s1[NR],s2[NR];
int n,m;
int nxt[NR];

int main(){
    scanf(&quot;%s&quot;,s1+1);
    scanf(&quot;%s&quot;,s2+1);
    n=strlen(s2+1);
    m=strlen(s1+1);
    for(int i=2,j=0;i&lt;=n;i++){
        while(j&gt;0&amp;&amp;s2[i]!=s2[j+1]) j=nxt[j];
        if(s2[i]==s2[j+1]) j++;
        nxt[i]=j;
    }
    for(int i=1,j=0;i&lt;=m;i++){
        while(j&gt;0&amp;&amp;s1[i]!=s2[j+1]) j=nxt[j];
        if(s1[i]==s2[j+1]) j++;
        if(j==n) printf(&quot;%d\n&quot;,i-n+1);
    }
    for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,nxt[i]);
    return 0;
}
</code></pre>
<h2 id="例题">例题</h2>
<h3 id="p5829-模板失配树">P5829 【模板】失配树</h3>
<p>失配树：跑完KMP后，将<em>nxt</em><sub><em>i</em></sub>作为<em>i</em>的父亲建成的树<br>
性质：每个点<em>i</em>的所有祖先都是<em>s</em>[1...<em>i</em>]的border<br>
这题在失配树上LCA即可<br>
由于一个字符串的border不能是自己本身，所以答案为LCA(<em>fa</em><sub><em>p</em></sub>,<em>fa</em><sub><em>q</em></sub>)</p>
<h3 id="p2375-noi2014-动物园">P2375 [NOI2014] 动物园</h3>
<p>在<em>nxt</em>数组上再维护一个<em>f</em>数组，与题目中的<em>num</em>类似（<em>f</em>能重叠）<br>
核心代码：</p>
<pre><code class="language-cpp">ans=1;  nxt[1]=0;  f[1]=1;  f[0]=0;
for(int i=2,j=0;i&lt;=n;i++){
    while(j&gt;0&amp;&amp;s[i]!=s[j+1]) j=nxt[j];
    if(s[i]==s[j+1]) j++;
    nxt[i]=j;
    f[i]=f[j]+1;
}
for(int i=2,j=0;i&lt;=n;i++){
    while(j&gt;0&amp;&amp;s[i]!=s[j+1]) j=nxt[j];
    if(s[i]==s[j+1]) j++;
    while(j&gt;i/2) j=nxt[j];
    ans*=(long long)(f[j]+1);
    ans%=1000000007;
}
</code></pre>
]]></content>
    </entry>
</feed>